  关于C++中继承的概念，已经看了无数遍，背了无数遍。很多知识点是清晰了又糊涂，记住了又忘记。
现在，是终结的时候了。结合java的一些概念，再次理解，融汇OO的各种概念。

1 永远的痛 3中继承方式
  共同点，私有成员都变成不可用。公有继承，公有保护保持原样，私有继承公有保护全私有，保护继
承公有保护全保护。

2 多态 分为静态的多态 由函数重载实现，和动态的多态由继承和虚函数实现。
多态,就是重载和重写.重载发生在一个类中.重写发生在子类,意思就是子类重写父类相同名称的方法.
刚学语言有的东西,不必搞得那么清楚,只有知道怎么用就行了,有的问题你要想真正把它搞得很懂,
短时间是不可能的,比如说接口,没有几年工作经验你根本不可能真正理解什么是接口,甚至有的人工作四,
五年也没搞明白什么是接口,不要花太多时间去搞这些不容易搞懂的问题.
重载的特性,方法名相同.返回类型,传入方法的参数不同(包括个数和类型).
重写的特性,方法名相同,返回类型,参数均相同,必须发生在子类.

20110617
用C写的类似C++的程序，比如glib。 那么就相当于材料没有变化，只是以全新的视角去思考问题
在实际生活中，同一件事情，用不同的视角去看会有不同感受，这种例子比比皆是。
现在要说的就是：用面向对象的思想去思考问题。好多年了，一直没有理解
以后我要去讲 OO

20120214
关于虚函数，以前只知在类外用指向派生类的基类指针调用虚函数。在看skia源码的时候，有一种用法：
类里定义 protect: virtual void onDraw(SkCanvas* canvas) 再定义一个 非虚函数 draw
draw里面调用 onDraw。类外： 执行gm->draw (当然draw可以在子类中重写，但因为他不是虚函数所以
这里必定调用基类的draw) 如果gm指向了其子类，那么draw的this就是子类的，所以draw里面调用的onDraw
(也有写成this->onDraw 这样看起来更明显) 就是子类的onDraw。当然如果draw里面只是简单调用了onDraw
那么大可不必包装一层draw，可以直接gm->onDraw 达到相同效果。这样做的意义可能是，我可以在draw里面
加入一些必要代码。而这部分又不许要在子类中重新实现。
