前言
   虽然接触C语言到现在已经有10年，但是无数次经历证明，我的逻辑思维能力很差。
无不出现低效进度缓慢和极简单问题无法理解的现象。这个现象伴随了我20年。因此
我十分痛苦。我渴望在技术上有所突破，但是我的能力跟YJ简直无法可比。	
   痛定思痛，我决定从零开始，从极简单问题开始，重新学习编程！20100524

1 长度对齐问题边界问题(这么简单的东西竟然不理解)
  a 经典算法  length = (length+3) & ~3;  4字节对齐
    演变：    length = (length+2的n次幂-1) & ~(2的n次幂-1)
    比如1024字节对齐:
		length = (length+1023) & ~1023
  b 等价算法 if( length%1024 ){
		    length = length - (length%1024) + 1024;
	      }
    显然这种算法没有2的n次幂的限制
  c 求对齐后的个数问题: *
	pitch = (pitch+7)/8;
  d Flash擦除时候的情景。由于每次擦除一个块(比如4k)，所以出现上述类似情景
    	for( i=0; i < DataSize ;i+=0x1000 ) {
		erase_4k_page( i );
	}
    这种问题，对于我来说就拿最简单情况测试就可以了，比如0x1001
    哎，没有办法，我就是这么笨，认了！
	for( i=0; i<(DataSize+0x1000-1)/0x1000; i++ ) {
		erase_4k_page( i*0x1000 );
       }
   f 边界问题一直困扰着我，专项加强一下 20100528

2 大小端问题：
  a 对于VC
	UI8 test[4] = {0x12, 0x34, 0x56, 0x78};
	UI32* data = (UI32*)test;
	printf("0x%x",*data); 的结果是 0x78563412
    对于greenHill 结果是0x12345678

3 关于递归问题-一直就没有理解过
  递归是从前向后想问题，循环是从后向前想问题。递归在实际的编程中并不常用，但是在某些
情况下，它是非常强有力而漂亮的工具。 我还不会使用递归，在minigui中出现了递归，那才是
比较高级的递归用法。e2p.c中savedata的时候也用到了递归，但是是一种蹩脚用法，根本就不是
一个具有递归特性的问题。不过也提出了一种思想。所以递归问题都可以反过来想。

4 20131022 调试libdvbpsi 很久没写C代码了，手生。
mjd = (unsigned short)(p_event->i_start_time >>24);
(unsigned short) 的优先级高于>>
5 20131023 写了一个简单的epg解析程序，过程中犯了无数多个错误。日程生活中，要像吃饭睡觉
说话一样，不停的写代码，才能保持。因为这就是我的日常生活。不停的写代码。

5 我的工作用 64位机器:
sizeof(int)=4 sizeof(long)=8 sizeof(long long)=8
sizeof(float)=4 sizeof(double)=8
sizeof(3.14)=8 sizeof(3.14f)=4

arm平台
int 4 
long 4 
long long 8

一个double数，在arm平台上  %d %ld 都显示负数  %lld 才好用
在64bit pc上  %ld时候就开始正常显示了

对于一个小数其默认类型为double型，如果需要指定为float型，需要在小数后面添加F或f后缀。

printf("float=%f  %.10f\n",3.1415926123456); 结果：float=3.141593 3.1415926123
%f可以打印float 和 double 精度靠 .x 指定

浮点数表示范围：
多数系统按IEEE-754标准，单精度4字节双精度8字节，分三部分：符号位、阶码和尾数。阶码即
指数，尾数即有效小数位数。单精度格式阶码占8位，尾数占24位，符号位1位，双精度则为11位
阶码，53位尾数和1位符号位，

arm平台：

float数范围
32位单精度浮点型（float）和64位双精度浮点型（double）

6 8位原码，反码，补码表示的范围：
-127~+127
-127~+127  有正负0之分
-128~+127

7 printf("%d  %x\n",-128,-128); 结果：-128  ffffff80（明显是补码）
printf("buma %i  %lx\n",-128,(long)-128); 结果：-128  ffffffffffffff80
printf("buma %i  %hhx\n",-128,-128); 结果：-128 80
l ll h hh 用来调整长度的

arm平台
int 4
long 4


# if __WORDSIZE == 64
typedef long int  int64_t;
# else
__extension__
typedef long long int  int64_t;
# endif
去看<stdint.h>

18 无论多小心都还是会犯错。修改ffmpeg timeshift功能进入缓冲个标志不消失问题的时候，
开始想通过改变duration的方法实现，就在统计duration时减了3，结果后来忘记改回去了。

19 要有“德国”精神，我懂的。

printf("%.15f\n", r);   .后面表示  precision 精确度。


20 2个float相乘


printf 2字节补0 的值：
printf("%04hx");  //注意：只写0不行  要指定有几位。

------------
前言
   虽然接触C语言到现在已经有10年，但是无数次经历证明，我的逻辑思维能力很差。
无不出现低效进度缓慢和极简单问题无法理解的现象。这个现象伴随了我20年。因此
我十分痛苦。我渴望在技术上有所突破，但是我的能力跟YJ简直无法可比。	
   痛定思痛，我决定从零开始，从极简单问题开始，重新学习编程！20100524

1 长度对齐问题边界问题(这么简单的东西竟然不理解)
  a 经典算法  length = (length+3) & ~3;  4字节对齐
    演变：    length = (length+2的n次幂-1) & ~(2的n次幂-1)
    比如1024字节对齐:
		length = (length+1023) & ~1023
  b 等价算法 if( length%1024 ){
		    length = length - (length%1024) + 1024;
	      }
    显然这种算法没有2的n次幂的限制
  c 求对齐后的个数问题: *
	pitch = (pitch+7)/8;
  d Flash擦除时候的情景。由于每次擦除一个块(比如4k)，所以出现上述类似情景
    	for( i=0; i < DataSize ;i+=0x1000 ) {
		erase_4k_page( i );
	}
    这种问题，对于我来说就拿最简单情况测试就可以了，比如0x1001
    哎，没有办法，我就是这么笨，认了！
	for( i=0; i<(DataSize+0x1000-1)/0x1000; i++ ) {
		erase_4k_page( i*0x1000 );
       }
   f 边界问题一直困扰着我，专项加强一下 20100528

2 大小端问题：
  a 对于VC
	UI8 test[4] = {0x12, 0x34, 0x56, 0x78};
	UI32* data = (UI32*)test;
	printf("0x%x",*data); 的结果是 0x78563412
    对于greenHill 结果是0x12345678

3 关于递归问题-一直就没有理解过
  递归是从前向后想问题，循环是从后向前想问题。递归在实际的编程中并不常用，但是在某些情况下，它是非常强有力而漂亮的工具。 我还不会使用递归，在minigui中出现了递归，那才是比较高级的递归用法。e2p.c中savedata的时候也用到了递归，但是是一种蹩脚用法，根本就不是一个具有递归特性的问题。不过也提出了一种思想。所以递归问题都可以反过来想。



