
2.7182818284590452353 4669606221036727158057024426033
2.7182818284590452353 5892833043843297513956819584345
2.7182818284590452353 6015155726123954549547909178518
2.7182818284590452353 6027387994352020253107029238719
2.7182818284590452353 6028747135130335684301757108228
2.7182818284590452353 6028747135266249775711117960854 (n=1+40个0)
2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427 (100位准确数字)

e ≈ 2.71828182845904523536028747135266249775724709369995957496696762772407\
6630353547594571382178525166427 (100位准确数字)

用 (1+1/n)^n
或者1+1/(1!)+1/(2!)+......+1/(n!)


更为一般的，指数函数e​^x有一个所有函数都不具备的性质，那就是它的导数还是它自己。具备这样性质的函数唯此一个。



欧拉《无穷小分析引论》



复数指数的意义，比如2＾i是什么含义？

a = 2^i

ln(a) = i*ln(2)

a = e^[i*ln(2)] = cos[ln(2)] + i*sin[ln(2)]

ln(2) = 0.6931....rad = 39.7144....deg

cos[ln(2)] = 0.7692...
sin[ln(2)] = 0.6389...

2^i = 0.7692... + i*0.6389...



调和级数 取值100000000  1亿时候为  18.99789641385255
得出欧拉常数：
0.57721565990019  （精确到了第七位）
取2亿，得出：19.69104359191438 （增加1亿次运算结果才增加了0.693）
得出欧拉常数：
0.57721566240207 （精确到了第八位，增加1亿次运算才精确了1位）
0.57721566490153 （正确值）


x=0:0.001:pi  // 0.001 表示精度
y=sin(x);
plot(x,y);
hold on
y=x；
hlot(x,y);

就画出了2条曲线。


axis equal  命令，保证x y 刻度相同














exp(3);  表示e^3


y=1+x+x.^2/2;    x^2  要换函数图的话  x后面要加 .  

一般地，形如y=x^a(a为常数）的函数，即以底数为自变量，幂为因变量，指数为常量的函数称为幂函数。

画圆
--> a=0:pi/20:2*pi;
--> r=2;
--> x=r*con(a);
--> x=r*cos(a);
--> y=r*sin(a);
--> plot(x,y);
--> axis equal


傅里叶级数
法国数学家傅里叶发现，任何周期函数都可以用正弦函数和余弦函数构成的无穷级数来表示


用MATLAB绘双扭线r^2=(a^2)*sin2t 

t = 0:.01:2*pi;
polar(t,sqrt(2^2*sin(2*t))


复数指数形式，在电学中应用广泛。就一个i^2=-1  为啥就这么大威力呢
为了计算方便。复数的代数运算和我们熟悉的实数运算相同，相当于用一个数字把向量的模和方向都表示出来了。


atan 反正切




　　外国著名数学家 　　
　  1、古希腊：泰勒斯、欧几里得，阿基米德，毕达哥拉斯，
　　2、德国：高斯、柯西、莱布尼兹、戴维·希尔伯特、歌德巴赫、克莱因、开普勒
　　3、法国：笛卡儿、拉格朗日、拉普拉斯、费马、泊松、嘉当、伽罗瓦、傅里叶
　　4、美国：Lars V.Ahlfors
　　5、英国：艾萨克·牛顿
　　6、瑞士：欧拉、丹尼尔·伯努利，，阿贝尔， ……
　　7、匈牙利：冯·诺依曼
　　8、挪威：伯努利









freemat里面
log 函数以e为低
log10 函数以10为底


The following piece of code plots the FFT for a sinusoidal signal: 
--> t = linspace(0,2*pi,128);
--> x = cos(15*t);
--> y = fft(x);
--> plot(t,abs(y));


Example
The following demonstrates the abs applied to a complex scalar. 
--> abs(3+4*i)

ans = 
 5 



偶而你会遇到一些在Matlab 里面熟悉的函式，却没有出现在FreeMat 里面，这时你除了自己撰
写m-script 之外，有一个更简单的方法。就是在网路上搜寻别人已经写好的m-script。例如，
randsample.m 或是 dct.m 这类的函式不是FreeMat 预设的函式。我们可以用Google 大神来搜
寻你所欠缺的函式，然后下载到FreeMat Path Tool 底下的相关路径。建议先设定一个专门放置
Toolbox 的目录，然后在这目录底下，做好不同学门的分类目录。例如，randsample.m 可以放
置在stats 分类底下。下载后在FreeMat 指令栏里执行randsample(5,2)，你会看到一个错误讯息，
提到还有其他需要的相关档案没有在你的系统当中，这时你可以重复Google 搜寻的动作，把其他
相关档案一一下载回来，就可以打造出你所需要的Matlab 环境。 



./share/freemat/toolbox  下面存放大量的 .m文件
可以把  dct.m  dct2.m 拷贝到 
/usr/share/freemat/toolbox/signal 下面
但是要注意：注释符号要用 %  而不是## 

http://users.powernet.co.uk/kienzle/octave/matcompat/scripts/signal/

dct  dct2 在freemat上没有成功


x=round(rand(4)*100)
y=dct2(x);


freemat 上没有dct2 但是在 octave上有
执行
x=round(rand(4)*100)
y=dct2(x);
可以运算出dct2


定义二维矩阵
a=[1 2 3 4;5 6 7 8;9 10 11 12];


octave:3> a=[61 19 50 20;82 26 61 45;89 90 82 43;93 59 53 97]
a =

   61   19   50   20
   82   26   61   45
   89   90   82   43
   93   59   53   97

octave:4> dct(a)
ans =

   162.5000    97.0000   123.0000   102.5000
   -22.7992   -43.4495    -7.6424   -49.7615
    -8.5000   -19.0000   -20.0000    14.5000
    -4.0862    30.9861    12.9071   -22.1426

octave:5> dct2(a)
ans =

   242.5000    32.1613    22.5000    33.2212
   -61.8263     7.9246   -10.7344    30.6881
   -16.5000   -14.7549    22.5000    -6.8770
     8.8322    16.6881   -35.0610    -6.9246

octave:6> 





y=x.^2   注意y=x平方  x后面要有.  不知到为何要这样。

注意，平方的符号前面要有一个点，Matlab 是把变量当做矩阵处理的，没加点的话，是对矩阵进行运算，加点之后就是对矩阵中的每个元素进行运算，我今天编程时就遇到这个问题了。



y=sin(x).*cos(x)  sinx乘以cosx 中间要加.














